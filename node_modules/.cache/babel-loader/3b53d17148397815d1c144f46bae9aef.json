{"ast":null,"code":"/*\n  Copyright 2019 Google LLC\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { timeout } from './timeout.js';\nimport '../_version.js';\nconst MAX_RETRY_TIME = 2000;\n/**\n * Returns a promise that resolves to a window client matching the passed\n * `resultingClientId`. For browsers that don't support `resultingClientId`\n * or if waiting for the resulting client to apper takes too long, resolve to\n * `undefined`.\n *\n * @param {string} [resultingClientId]\n * @return {Promise<Client|undefined>}\n * @private\n */\n\nexport async function resultingClientExists(resultingClientId) {\n  if (!resultingClientId) {\n    return;\n  }\n\n  let existingWindows = await self.clients.matchAll({\n    type: 'window'\n  });\n  const existingWindowIds = new Set(existingWindows.map(w => w.id));\n  let resultingWindow;\n  const startTime = performance.now(); // Only wait up to `MAX_RETRY_TIME` to find a matching client.\n\n  while (performance.now() - startTime < MAX_RETRY_TIME) {\n    existingWindows = await self.clients.matchAll({\n      type: 'window'\n    });\n    resultingWindow = existingWindows.find(w => {\n      if (resultingClientId) {\n        // If we have a `resultingClientId`, we can match on that.\n        return w.id === resultingClientId;\n      } else {\n        // Otherwise match on finding a window not in `existingWindowIds`.\n        return !existingWindowIds.has(w.id);\n      }\n    });\n\n    if (resultingWindow) {\n      break;\n    } // Sleep for 100ms and retry.\n\n\n    await timeout(100);\n  }\n\n  return resultingWindow;\n}","map":{"version":3,"sources":["/Users/matthewcohen/Desktop/HTTBProject/HTTBFrontend/react-crud/node_modules/workbox-core/_private/resultingClientExists.js"],"names":["timeout","MAX_RETRY_TIME","resultingClientExists","resultingClientId","existingWindows","self","clients","matchAll","type","existingWindowIds","Set","map","w","id","resultingWindow","startTime","performance","now","find","has"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,OAAT,QAAwB,cAAxB;AACA,OAAO,gBAAP;AACA,MAAMC,cAAc,GAAG,IAAvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,eAAeC,qBAAf,CAAqCC,iBAArC,EAAwD;AAC3D,MAAI,CAACA,iBAAL,EAAwB;AACpB;AACH;;AACD,MAAIC,eAAe,GAAG,MAAMC,IAAI,CAACC,OAAL,CAAaC,QAAb,CAAsB;AAAEC,IAAAA,IAAI,EAAE;AAAR,GAAtB,CAA5B;AACA,QAAMC,iBAAiB,GAAG,IAAIC,GAAJ,CAAQN,eAAe,CAACO,GAAhB,CAAqBC,CAAD,IAAOA,CAAC,CAACC,EAA7B,CAAR,CAA1B;AACA,MAAIC,eAAJ;AACA,QAAMC,SAAS,GAAGC,WAAW,CAACC,GAAZ,EAAlB,CAP2D,CAQ3D;;AACA,SAAOD,WAAW,CAACC,GAAZ,KAAoBF,SAApB,GAAgCd,cAAvC,EAAuD;AACnDG,IAAAA,eAAe,GAAG,MAAMC,IAAI,CAACC,OAAL,CAAaC,QAAb,CAAsB;AAAEC,MAAAA,IAAI,EAAE;AAAR,KAAtB,CAAxB;AACAM,IAAAA,eAAe,GAAGV,eAAe,CAACc,IAAhB,CAAsBN,CAAD,IAAO;AAC1C,UAAIT,iBAAJ,EAAuB;AACnB;AACA,eAAOS,CAAC,CAACC,EAAF,KAASV,iBAAhB;AACH,OAHD,MAIK;AACD;AACA,eAAO,CAACM,iBAAiB,CAACU,GAAlB,CAAsBP,CAAC,CAACC,EAAxB,CAAR;AACH;AACJ,KATiB,CAAlB;;AAUA,QAAIC,eAAJ,EAAqB;AACjB;AACH,KAdkD,CAenD;;;AACA,UAAMd,OAAO,CAAC,GAAD,CAAb;AACH;;AACD,SAAOc,eAAP;AACH","sourcesContent":["/*\n  Copyright 2019 Google LLC\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { timeout } from './timeout.js';\nimport '../_version.js';\nconst MAX_RETRY_TIME = 2000;\n/**\n * Returns a promise that resolves to a window client matching the passed\n * `resultingClientId`. For browsers that don't support `resultingClientId`\n * or if waiting for the resulting client to apper takes too long, resolve to\n * `undefined`.\n *\n * @param {string} [resultingClientId]\n * @return {Promise<Client|undefined>}\n * @private\n */\nexport async function resultingClientExists(resultingClientId) {\n    if (!resultingClientId) {\n        return;\n    }\n    let existingWindows = await self.clients.matchAll({ type: 'window' });\n    const existingWindowIds = new Set(existingWindows.map((w) => w.id));\n    let resultingWindow;\n    const startTime = performance.now();\n    // Only wait up to `MAX_RETRY_TIME` to find a matching client.\n    while (performance.now() - startTime < MAX_RETRY_TIME) {\n        existingWindows = await self.clients.matchAll({ type: 'window' });\n        resultingWindow = existingWindows.find((w) => {\n            if (resultingClientId) {\n                // If we have a `resultingClientId`, we can match on that.\n                return w.id === resultingClientId;\n            }\n            else {\n                // Otherwise match on finding a window not in `existingWindowIds`.\n                return !existingWindowIds.has(w.id);\n            }\n        });\n        if (resultingWindow) {\n            break;\n        }\n        // Sleep for 100ms and retry.\n        await timeout(100);\n    }\n    return resultingWindow;\n}\n"]},"metadata":{},"sourceType":"module"}