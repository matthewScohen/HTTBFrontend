{"ast":null,"code":"/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\n/**\n * A class that wraps common IndexedDB functionality in a promise-based API.\n * It exposes all the underlying power and functionality of IndexedDB, but\n * wraps the most commonly used features in a way that's much simpler to use.\n *\n * @private\n */\n\nexport class DBWrapper {\n  /**\n   * @param {string} name\n   * @param {number} version\n   * @param {Object=} [callback]\n   * @param {!Function} [callbacks.onupgradeneeded]\n   * @param {!Function} [callbacks.onversionchange] Defaults to\n   *     DBWrapper.prototype._onversionchange when not specified.\n   * @private\n   */\n  constructor(name, version, {\n    onupgradeneeded,\n    onversionchange\n  } = {}) {\n    this._db = null;\n    this._name = name;\n    this._version = version;\n    this._onupgradeneeded = onupgradeneeded;\n\n    this._onversionchange = onversionchange || (() => this.close());\n  }\n  /**\n   * Returns the IDBDatabase instance (not normally needed).\n   * @return {IDBDatabase|undefined}\n   *\n   * @private\n   */\n\n\n  get db() {\n    return this._db;\n  }\n  /**\n   * Opens a connected to an IDBDatabase, invokes any onupgradedneeded\n   * callback, and added an onversionchange callback to the database.\n   *\n   * @return {IDBDatabase}\n   * @private\n   */\n\n\n  async open() {\n    if (this._db) return;\n    this._db = await new Promise((resolve, reject) => {\n      // This flag is flipped to true if the timeout callback runs prior\n      // to the request failing or succeeding. Note: we use a timeout instead\n      // of an onblocked handler since there are cases where onblocked will\n      // never never run. A timeout better handles all possible scenarios:\n      // https://github.com/w3c/IndexedDB/issues/223\n      let openRequestTimedOut = false;\n      setTimeout(() => {\n        openRequestTimedOut = true;\n        reject(new Error('The open request was blocked and timed out'));\n      }, this.OPEN_TIMEOUT);\n      const openRequest = indexedDB.open(this._name, this._version);\n\n      openRequest.onerror = () => reject(openRequest.error);\n\n      openRequest.onupgradeneeded = evt => {\n        if (openRequestTimedOut) {\n          openRequest.transaction.abort();\n          openRequest.result.close();\n        } else if (typeof this._onupgradeneeded === 'function') {\n          this._onupgradeneeded(evt);\n        }\n      };\n\n      openRequest.onsuccess = () => {\n        const db = openRequest.result;\n\n        if (openRequestTimedOut) {\n          db.close();\n        } else {\n          db.onversionchange = this._onversionchange.bind(this);\n          resolve(db);\n        }\n      };\n    });\n    return this;\n  }\n  /**\n   * Polyfills the native `getKey()` method. Note, this is overridden at\n   * runtime if the browser supports the native method.\n   *\n   * @param {string} storeName\n   * @param {*} query\n   * @return {Array}\n   * @private\n   */\n\n\n  async getKey(storeName, query) {\n    return (await this.getAllKeys(storeName, query, 1))[0];\n  }\n  /**\n   * Polyfills the native `getAll()` method. Note, this is overridden at\n   * runtime if the browser supports the native method.\n   *\n   * @param {string} storeName\n   * @param {*} query\n   * @param {number} count\n   * @return {Array}\n   * @private\n   */\n\n\n  async getAll(storeName, query, count) {\n    return await this.getAllMatching(storeName, {\n      query,\n      count\n    });\n  }\n  /**\n   * Polyfills the native `getAllKeys()` method. Note, this is overridden at\n   * runtime if the browser supports the native method.\n   *\n   * @param {string} storeName\n   * @param {*} query\n   * @param {number} count\n   * @return {Array}\n   * @private\n   */\n\n\n  async getAllKeys(storeName, query, count) {\n    const entries = await this.getAllMatching(storeName, {\n      query,\n      count,\n      includeKeys: true\n    });\n    return entries.map(entry => entry.key);\n  }\n  /**\n   * Supports flexible lookup in an object store by specifying an index,\n   * query, direction, and count. This method returns an array of objects\n   * with the signature .\n   *\n   * @param {string} storeName\n   * @param {Object} [opts]\n   * @param {string} [opts.index] The index to use (if specified).\n   * @param {*} [opts.query]\n   * @param {IDBCursorDirection} [opts.direction]\n   * @param {number} [opts.count] The max number of results to return.\n   * @param {boolean} [opts.includeKeys] When true, the structure of the\n   *     returned objects is changed from an array of values to an array of\n   *     objects in the form {key, primaryKey, value}.\n   * @return {Array}\n   * @private\n   */\n\n\n  async getAllMatching(storeName, {\n    index,\n    query = null,\n    // IE/Edge errors if query === `undefined`.\n    direction = 'next',\n    count,\n    includeKeys = false\n  } = {}) {\n    return await this.transaction([storeName], 'readonly', (txn, done) => {\n      const store = txn.objectStore(storeName);\n      const target = index ? store.index(index) : store;\n      const results = [];\n      const request = target.openCursor(query, direction);\n\n      request.onsuccess = () => {\n        const cursor = request.result;\n\n        if (cursor) {\n          results.push(includeKeys ? cursor : cursor.value);\n\n          if (count && results.length >= count) {\n            done(results);\n          } else {\n            cursor.continue();\n          }\n        } else {\n          done(results);\n        }\n      };\n    });\n  }\n  /**\n   * Accepts a list of stores, a transaction type, and a callback and\n   * performs a transaction. A promise is returned that resolves to whatever\n   * value the callback chooses. The callback holds all the transaction logic\n   * and is invoked with two arguments:\n   *   1. The IDBTransaction object\n   *   2. A `done` function, that's used to resolve the promise when\n   *      when the transaction is done, if passed a value, the promise is\n   *      resolved to that value.\n   *\n   * @param {Array<string>} storeNames An array of object store names\n   *     involved in the transaction.\n   * @param {string} type Can be `readonly` or `readwrite`.\n   * @param {!Function} callback\n   * @return {*} The result of the transaction ran by the callback.\n   * @private\n   */\n\n\n  async transaction(storeNames, type, callback) {\n    await this.open();\n    return await new Promise((resolve, reject) => {\n      const txn = this._db.transaction(storeNames, type);\n\n      txn.onabort = () => reject(txn.error);\n\n      txn.oncomplete = () => resolve();\n\n      callback(txn, value => resolve(value));\n    });\n  }\n  /**\n   * Delegates async to a native IDBObjectStore method.\n   *\n   * @param {string} method The method name.\n   * @param {string} storeName The object store name.\n   * @param {string} type Can be `readonly` or `readwrite`.\n   * @param {...*} args The list of args to pass to the native method.\n   * @return {*} The result of the transaction.\n   * @private\n   */\n\n\n  async _call(method, storeName, type, ...args) {\n    const callback = (txn, done) => {\n      const objStore = txn.objectStore(storeName); // TODO(philipwalton): Fix this underlying TS2684 error.\n      // @ts-ignore\n\n      const request = objStore[method].apply(objStore, args);\n\n      request.onsuccess = () => done(request.result);\n    };\n\n    return await this.transaction([storeName], type, callback);\n  }\n  /**\n   * Closes the connection opened by `DBWrapper.open()`. Generally this method\n   * doesn't need to be called since:\n   *   1. It's usually better to keep a connection open since opening\n   *      a new connection is somewhat slow.\n   *   2. Connections are automatically closed when the reference is\n   *      garbage collected.\n   * The primary use case for needing to close a connection is when another\n   * reference (typically in another tab) needs to upgrade it and would be\n   * blocked by the current, open connection.\n   *\n   * @private\n   */\n\n\n  close() {\n    if (this._db) {\n      this._db.close();\n\n      this._db = null;\n    }\n  }\n\n} // Exposed on the prototype to let users modify the default timeout on a\n// per-instance or global basis.\n\nDBWrapper.prototype.OPEN_TIMEOUT = 2000; // Wrap native IDBObjectStore methods according to their mode.\n\nconst methodsToWrap = {\n  readonly: ['get', 'count', 'getKey', 'getAll', 'getAllKeys'],\n  readwrite: ['add', 'put', 'clear', 'delete']\n};\n\nfor (const [mode, methods] of Object.entries(methodsToWrap)) {\n  for (const method of methods) {\n    if (method in IDBObjectStore.prototype) {\n      // Don't use arrow functions here since we're outside of the class.\n      DBWrapper.prototype[method] = async function (storeName, ...args) {\n        return await this._call(method, storeName, mode, ...args);\n      };\n    }\n  }\n}","map":{"version":3,"sources":["/Users/matthewcohen/Desktop/HTTBProject/HTTBFrontend/react-crud/node_modules/workbox-core/_private/DBWrapper.js"],"names":["DBWrapper","constructor","name","version","onupgradeneeded","onversionchange","_db","_name","_version","_onupgradeneeded","_onversionchange","close","db","open","Promise","resolve","reject","openRequestTimedOut","setTimeout","Error","OPEN_TIMEOUT","openRequest","indexedDB","onerror","error","evt","transaction","abort","result","onsuccess","bind","getKey","storeName","query","getAllKeys","getAll","count","getAllMatching","entries","includeKeys","map","entry","key","index","direction","txn","done","store","objectStore","target","results","request","openCursor","cursor","push","value","length","continue","storeNames","type","callback","onabort","oncomplete","_call","method","args","objStore","apply","prototype","methodsToWrap","readonly","readwrite","mode","methods","Object","IDBObjectStore"],"mappings":"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","sourcesContent":["/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\n/**\n * A class that wraps common IndexedDB functionality in a promise-based API.\n * It exposes all the underlying power and functionality of IndexedDB, but\n * wraps the most commonly used features in a way that's much simpler to use.\n *\n * @private\n */\nexport class DBWrapper {\n    /**\n     * @param {string} name\n     * @param {number} version\n     * @param {Object=} [callback]\n     * @param {!Function} [callbacks.onupgradeneeded]\n     * @param {!Function} [callbacks.onversionchange] Defaults to\n     *     DBWrapper.prototype._onversionchange when not specified.\n     * @private\n     */\n    constructor(name, version, { onupgradeneeded, onversionchange, } = {}) {\n        this._db = null;\n        this._name = name;\n        this._version = version;\n        this._onupgradeneeded = onupgradeneeded;\n        this._onversionchange = onversionchange || (() => this.close());\n    }\n    /**\n     * Returns the IDBDatabase instance (not normally needed).\n     * @return {IDBDatabase|undefined}\n     *\n     * @private\n     */\n    get db() {\n        return this._db;\n    }\n    /**\n     * Opens a connected to an IDBDatabase, invokes any onupgradedneeded\n     * callback, and added an onversionchange callback to the database.\n     *\n     * @return {IDBDatabase}\n     * @private\n     */\n    async open() {\n        if (this._db)\n            return;\n        this._db = await new Promise((resolve, reject) => {\n            // This flag is flipped to true if the timeout callback runs prior\n            // to the request failing or succeeding. Note: we use a timeout instead\n            // of an onblocked handler since there are cases where onblocked will\n            // never never run. A timeout better handles all possible scenarios:\n            // https://github.com/w3c/IndexedDB/issues/223\n            let openRequestTimedOut = false;\n            setTimeout(() => {\n                openRequestTimedOut = true;\n                reject(new Error('The open request was blocked and timed out'));\n            }, this.OPEN_TIMEOUT);\n            const openRequest = indexedDB.open(this._name, this._version);\n            openRequest.onerror = () => reject(openRequest.error);\n            openRequest.onupgradeneeded = (evt) => {\n                if (openRequestTimedOut) {\n                    openRequest.transaction.abort();\n                    openRequest.result.close();\n                }\n                else if (typeof this._onupgradeneeded === 'function') {\n                    this._onupgradeneeded(evt);\n                }\n            };\n            openRequest.onsuccess = () => {\n                const db = openRequest.result;\n                if (openRequestTimedOut) {\n                    db.close();\n                }\n                else {\n                    db.onversionchange = this._onversionchange.bind(this);\n                    resolve(db);\n                }\n            };\n        });\n        return this;\n    }\n    /**\n     * Polyfills the native `getKey()` method. Note, this is overridden at\n     * runtime if the browser supports the native method.\n     *\n     * @param {string} storeName\n     * @param {*} query\n     * @return {Array}\n     * @private\n     */\n    async getKey(storeName, query) {\n        return (await this.getAllKeys(storeName, query, 1))[0];\n    }\n    /**\n     * Polyfills the native `getAll()` method. Note, this is overridden at\n     * runtime if the browser supports the native method.\n     *\n     * @param {string} storeName\n     * @param {*} query\n     * @param {number} count\n     * @return {Array}\n     * @private\n     */\n    async getAll(storeName, query, count) {\n        return await this.getAllMatching(storeName, { query, count });\n    }\n    /**\n     * Polyfills the native `getAllKeys()` method. Note, this is overridden at\n     * runtime if the browser supports the native method.\n     *\n     * @param {string} storeName\n     * @param {*} query\n     * @param {number} count\n     * @return {Array}\n     * @private\n     */\n    async getAllKeys(storeName, query, count) {\n        const entries = await this.getAllMatching(storeName, { query, count, includeKeys: true });\n        return entries.map((entry) => entry.key);\n    }\n    /**\n     * Supports flexible lookup in an object store by specifying an index,\n     * query, direction, and count. This method returns an array of objects\n     * with the signature .\n     *\n     * @param {string} storeName\n     * @param {Object} [opts]\n     * @param {string} [opts.index] The index to use (if specified).\n     * @param {*} [opts.query]\n     * @param {IDBCursorDirection} [opts.direction]\n     * @param {number} [opts.count] The max number of results to return.\n     * @param {boolean} [opts.includeKeys] When true, the structure of the\n     *     returned objects is changed from an array of values to an array of\n     *     objects in the form {key, primaryKey, value}.\n     * @return {Array}\n     * @private\n     */\n    async getAllMatching(storeName, { index, query = null, // IE/Edge errors if query === `undefined`.\n    direction = 'next', count, includeKeys = false, } = {}) {\n        return await this.transaction([storeName], 'readonly', (txn, done) => {\n            const store = txn.objectStore(storeName);\n            const target = index ? store.index(index) : store;\n            const results = [];\n            const request = target.openCursor(query, direction);\n            request.onsuccess = () => {\n                const cursor = request.result;\n                if (cursor) {\n                    results.push(includeKeys ? cursor : cursor.value);\n                    if (count && results.length >= count) {\n                        done(results);\n                    }\n                    else {\n                        cursor.continue();\n                    }\n                }\n                else {\n                    done(results);\n                }\n            };\n        });\n    }\n    /**\n     * Accepts a list of stores, a transaction type, and a callback and\n     * performs a transaction. A promise is returned that resolves to whatever\n     * value the callback chooses. The callback holds all the transaction logic\n     * and is invoked with two arguments:\n     *   1. The IDBTransaction object\n     *   2. A `done` function, that's used to resolve the promise when\n     *      when the transaction is done, if passed a value, the promise is\n     *      resolved to that value.\n     *\n     * @param {Array<string>} storeNames An array of object store names\n     *     involved in the transaction.\n     * @param {string} type Can be `readonly` or `readwrite`.\n     * @param {!Function} callback\n     * @return {*} The result of the transaction ran by the callback.\n     * @private\n     */\n    async transaction(storeNames, type, callback) {\n        await this.open();\n        return await new Promise((resolve, reject) => {\n            const txn = this._db.transaction(storeNames, type);\n            txn.onabort = () => reject(txn.error);\n            txn.oncomplete = () => resolve();\n            callback(txn, (value) => resolve(value));\n        });\n    }\n    /**\n     * Delegates async to a native IDBObjectStore method.\n     *\n     * @param {string} method The method name.\n     * @param {string} storeName The object store name.\n     * @param {string} type Can be `readonly` or `readwrite`.\n     * @param {...*} args The list of args to pass to the native method.\n     * @return {*} The result of the transaction.\n     * @private\n     */\n    async _call(method, storeName, type, ...args) {\n        const callback = (txn, done) => {\n            const objStore = txn.objectStore(storeName);\n            // TODO(philipwalton): Fix this underlying TS2684 error.\n            // @ts-ignore\n            const request = objStore[method].apply(objStore, args);\n            request.onsuccess = () => done(request.result);\n        };\n        return await this.transaction([storeName], type, callback);\n    }\n    /**\n     * Closes the connection opened by `DBWrapper.open()`. Generally this method\n     * doesn't need to be called since:\n     *   1. It's usually better to keep a connection open since opening\n     *      a new connection is somewhat slow.\n     *   2. Connections are automatically closed when the reference is\n     *      garbage collected.\n     * The primary use case for needing to close a connection is when another\n     * reference (typically in another tab) needs to upgrade it and would be\n     * blocked by the current, open connection.\n     *\n     * @private\n     */\n    close() {\n        if (this._db) {\n            this._db.close();\n            this._db = null;\n        }\n    }\n}\n// Exposed on the prototype to let users modify the default timeout on a\n// per-instance or global basis.\nDBWrapper.prototype.OPEN_TIMEOUT = 2000;\n// Wrap native IDBObjectStore methods according to their mode.\nconst methodsToWrap = {\n    readonly: ['get', 'count', 'getKey', 'getAll', 'getAllKeys'],\n    readwrite: ['add', 'put', 'clear', 'delete'],\n};\nfor (const [mode, methods] of Object.entries(methodsToWrap)) {\n    for (const method of methods) {\n        if (method in IDBObjectStore.prototype) {\n            // Don't use arrow functions here since we're outside of the class.\n            DBWrapper.prototype[method] =\n                async function (storeName, ...args) {\n                    return await this._call(method, storeName, mode, ...args);\n                };\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}