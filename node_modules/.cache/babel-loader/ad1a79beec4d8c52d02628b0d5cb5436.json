{"ast":null,"code":"/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { cacheWrapper } from 'workbox-core/_private/cacheWrapper.js';\nimport { fetchWrapper } from 'workbox-core/_private/fetchWrapper.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { copyResponse } from 'workbox-core/copyResponse.js';\nimport { createCacheKey } from './utils/createCacheKey.js';\nimport { printCleanupDetails } from './utils/printCleanupDetails.js';\nimport { printInstallDetails } from './utils/printInstallDetails.js';\nimport './_version.js';\n/**\n * Performs efficient precaching of assets.\n *\n * @memberof module:workbox-precaching\n */\n\nclass PrecacheController {\n  /**\n   * Create a new PrecacheController.\n   *\n   * @param {string} [cacheName] An optional name for the cache, to override\n   * the default precache name.\n   */\n  constructor(cacheName) {\n    this._cacheName = cacheNames.getPrecacheName(cacheName);\n    this._urlsToCacheKeys = new Map();\n    this._urlsToCacheModes = new Map();\n    this._cacheKeysToIntegrities = new Map();\n  }\n  /**\n   * This method will add items to the precache list, removing duplicates\n   * and ensuring the information is valid.\n   *\n   * @param {\n   * Array<module:workbox-precaching.PrecacheController.PrecacheEntry|string>\n   * } entries Array of entries to precache.\n   */\n\n\n  addToCacheList(entries) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isArray(entries, {\n        moduleName: 'workbox-precaching',\n        className: 'PrecacheController',\n        funcName: 'addToCacheList',\n        paramName: 'entries'\n      });\n    }\n\n    const urlsToWarnAbout = [];\n\n    for (const entry of entries) {\n      // See https://github.com/GoogleChrome/workbox/issues/2259\n      if (typeof entry === 'string') {\n        urlsToWarnAbout.push(entry);\n      } else if (entry && entry.revision === undefined) {\n        urlsToWarnAbout.push(entry.url);\n      }\n\n      const {\n        cacheKey,\n        url\n      } = createCacheKey(entry);\n      const cacheMode = typeof entry !== 'string' && entry.revision ? 'reload' : 'default';\n\n      if (this._urlsToCacheKeys.has(url) && this._urlsToCacheKeys.get(url) !== cacheKey) {\n        throw new WorkboxError('add-to-cache-list-conflicting-entries', {\n          firstEntry: this._urlsToCacheKeys.get(url),\n          secondEntry: cacheKey\n        });\n      }\n\n      if (typeof entry !== 'string' && entry.integrity) {\n        if (this._cacheKeysToIntegrities.has(cacheKey) && this._cacheKeysToIntegrities.get(cacheKey) !== entry.integrity) {\n          throw new WorkboxError('add-to-cache-list-conflicting-integrities', {\n            url\n          });\n        }\n\n        this._cacheKeysToIntegrities.set(cacheKey, entry.integrity);\n      }\n\n      this._urlsToCacheKeys.set(url, cacheKey);\n\n      this._urlsToCacheModes.set(url, cacheMode);\n\n      if (urlsToWarnAbout.length > 0) {\n        const warningMessage = `Workbox is precaching URLs without revision ` + `info: ${urlsToWarnAbout.join(', ')}\\nThis is generally NOT safe. ` + `Learn more at https://bit.ly/wb-precache`;\n\n        if (process.env.NODE_ENV === 'production') {\n          // Use console directly to display this warning without bloating\n          // bundle sizes by pulling in all of the logger codebase in prod.\n          console.warn(warningMessage);\n        } else {\n          logger.warn(warningMessage);\n        }\n      }\n    }\n  }\n  /**\n   * Precaches new and updated assets. Call this method from the service worker\n   * install event.\n   *\n   * @param {Object} options\n   * @param {Event} [options.event] The install event (if needed).\n   * @param {Array<Object>} [options.plugins] Plugins to be used for fetching\n   * and caching during install.\n   * @return {Promise<module:workbox-precaching.InstallResult>}\n   */\n\n\n  async install({\n    event,\n    plugins\n  } = {}) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (plugins) {\n        assert.isArray(plugins, {\n          moduleName: 'workbox-precaching',\n          className: 'PrecacheController',\n          funcName: 'install',\n          paramName: 'plugins'\n        });\n      }\n    }\n\n    const toBePrecached = [];\n    const alreadyPrecached = [];\n    const cache = await self.caches.open(this._cacheName);\n    const alreadyCachedRequests = await cache.keys();\n    const existingCacheKeys = new Set(alreadyCachedRequests.map(request => request.url));\n\n    for (const [url, cacheKey] of this._urlsToCacheKeys) {\n      if (existingCacheKeys.has(cacheKey)) {\n        alreadyPrecached.push(url);\n      } else {\n        toBePrecached.push({\n          cacheKey,\n          url\n        });\n      }\n    }\n\n    const precacheRequests = toBePrecached.map(({\n      cacheKey,\n      url\n    }) => {\n      const integrity = this._cacheKeysToIntegrities.get(cacheKey);\n\n      const cacheMode = this._urlsToCacheModes.get(url);\n\n      return this._addURLToCache({\n        cacheKey,\n        cacheMode,\n        event,\n        integrity,\n        plugins,\n        url\n      });\n    });\n    await Promise.all(precacheRequests);\n    const updatedURLs = toBePrecached.map(item => item.url);\n\n    if (process.env.NODE_ENV !== 'production') {\n      printInstallDetails(updatedURLs, alreadyPrecached);\n    }\n\n    return {\n      updatedURLs,\n      notUpdatedURLs: alreadyPrecached\n    };\n  }\n  /**\n   * Deletes assets that are no longer present in the current precache manifest.\n   * Call this method from the service worker activate event.\n   *\n   * @return {Promise<module:workbox-precaching.CleanupResult>}\n   */\n\n\n  async activate() {\n    const cache = await self.caches.open(this._cacheName);\n    const currentlyCachedRequests = await cache.keys();\n    const expectedCacheKeys = new Set(this._urlsToCacheKeys.values());\n    const deletedURLs = [];\n\n    for (const request of currentlyCachedRequests) {\n      if (!expectedCacheKeys.has(request.url)) {\n        await cache.delete(request);\n        deletedURLs.push(request.url);\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      printCleanupDetails(deletedURLs);\n    }\n\n    return {\n      deletedURLs\n    };\n  }\n  /**\n   * Requests the entry and saves it to the cache if the response is valid.\n   * By default, any response with a status code of less than 400 (including\n   * opaque responses) is considered valid.\n   *\n   * If you need to use custom criteria to determine what's valid and what\n   * isn't, then pass in an item in `options.plugins` that implements the\n   * `cacheWillUpdate()` lifecycle event.\n   *\n   * @private\n   * @param {Object} options\n   * @param {string} options.cacheKey The string to use a cache key.\n   * @param {string} options.url The URL to fetch and cache.\n   * @param {string} [options.cacheMode] The cache mode for the network request.\n   * @param {Event} [options.event] The install event (if passed).\n   * @param {Array<Object>} [options.plugins] An array of plugins to apply to\n   * fetch and caching.\n   * @param {string} [options.integrity] The value to use for the `integrity`\n   * field when making the request.\n   */\n\n\n  async _addURLToCache({\n    cacheKey,\n    url,\n    cacheMode,\n    event,\n    plugins,\n    integrity\n  }) {\n    const request = new Request(url, {\n      integrity,\n      cache: cacheMode,\n      credentials: 'same-origin'\n    });\n    let response = await fetchWrapper.fetch({\n      event,\n      plugins,\n      request\n    }); // Allow developers to override the default logic about what is and isn't\n    // valid by passing in a plugin implementing cacheWillUpdate(), e.g.\n    // a `CacheableResponsePlugin` instance.\n\n    let cacheWillUpdatePlugin;\n\n    for (const plugin of plugins || []) {\n      if ('cacheWillUpdate' in plugin) {\n        cacheWillUpdatePlugin = plugin;\n      }\n    }\n\n    const isValidResponse = cacheWillUpdatePlugin ? // Use a callback if provided. It returns a truthy value if valid.\n    // NOTE: invoke the method on the plugin instance so the `this` context\n    // is correct.\n    await cacheWillUpdatePlugin.cacheWillUpdate({\n      event,\n      request,\n      response\n    }) : // Otherwise, default to considering any response status under 400 valid.\n    // This includes, by default, considering opaque responses valid.\n    response.status < 400; // Consider this a failure, leading to the `install` handler failing, if\n    // we get back an invalid response.\n\n    if (!isValidResponse) {\n      throw new WorkboxError('bad-precaching-response', {\n        url,\n        status: response.status\n      });\n    } // Redirected responses cannot be used to satisfy a navigation request, so\n    // any redirected response must be \"copied\" rather than cloned, so the new\n    // response doesn't contain the `redirected` flag. See:\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=669363&desc=2#c1\n\n\n    if (response.redirected) {\n      response = await copyResponse(response);\n    }\n\n    await cacheWrapper.put({\n      event,\n      plugins,\n      response,\n      // `request` already uses `url`. We may be able to reuse it.\n      request: cacheKey === url ? request : new Request(cacheKey),\n      cacheName: this._cacheName,\n      matchOptions: {\n        ignoreSearch: true\n      }\n    });\n  }\n  /**\n   * Returns a mapping of a precached URL to the corresponding cache key, taking\n   * into account the revision information for the URL.\n   *\n   * @return {Map<string, string>} A URL to cache key mapping.\n   */\n\n\n  getURLsToCacheKeys() {\n    return this._urlsToCacheKeys;\n  }\n  /**\n   * Returns a list of all the URLs that have been precached by the current\n   * service worker.\n   *\n   * @return {Array<string>} The precached URLs.\n   */\n\n\n  getCachedURLs() {\n    return [...this._urlsToCacheKeys.keys()];\n  }\n  /**\n   * Returns the cache key used for storing a given URL. If that URL is\n   * unversioned, like `/index.html', then the cache key will be the original\n   * URL with a search parameter appended to it.\n   *\n   * @param {string} url A URL whose cache key you want to look up.\n   * @return {string} The versioned URL that corresponds to a cache key\n   * for the original URL, or undefined if that URL isn't precached.\n   */\n\n\n  getCacheKeyForURL(url) {\n    const urlObject = new URL(url, location.href);\n    return this._urlsToCacheKeys.get(urlObject.href);\n  }\n  /**\n   * This acts as a drop-in replacement for [`cache.match()`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/match)\n   * with the following differences:\n   *\n   * - It knows what the name of the precache is, and only checks in that cache.\n   * - It allows you to pass in an \"original\" URL without versioning parameters,\n   * and it will automatically look up the correct cache key for the currently\n   * active revision of that URL.\n   *\n   * E.g., `matchPrecache('index.html')` will find the correct precached\n   * response for the currently active service worker, even if the actual cache\n   * key is `'/index.html?__WB_REVISION__=1234abcd'`.\n   *\n   * @param {string|Request} request The key (without revisioning parameters)\n   * to look up in the precache.\n   * @return {Promise<Response|undefined>}\n   */\n\n\n  async matchPrecache(request) {\n    const url = request instanceof Request ? request.url : request;\n    const cacheKey = this.getCacheKeyForURL(url);\n\n    if (cacheKey) {\n      const cache = await self.caches.open(this._cacheName);\n      return cache.match(cacheKey);\n    }\n\n    return undefined;\n  }\n  /**\n   * Returns a function that can be used within a\n   * {@link module:workbox-routing.Route} that will find a response for the\n   * incoming request against the precache.\n   *\n   * If for an unexpected reason there is a cache miss for the request,\n   * this will fall back to retrieving the `Response` via `fetch()` when\n   * `fallbackToNetwork` is `true`.\n   *\n   * @param {boolean} [fallbackToNetwork=true] Whether to attempt to get the\n   * response from the network if there's a precache miss.\n   * @return {module:workbox-routing~handlerCallback}\n   */\n\n\n  createHandler(fallbackToNetwork = true) {\n    return async ({\n      request\n    }) => {\n      try {\n        const response = await this.matchPrecache(request);\n\n        if (response) {\n          return response;\n        } // This shouldn't normally happen, but there are edge cases:\n        // https://github.com/GoogleChrome/workbox/issues/1441\n\n\n        throw new WorkboxError('missing-precache-entry', {\n          cacheName: this._cacheName,\n          url: request instanceof Request ? request.url : request\n        });\n      } catch (error) {\n        if (fallbackToNetwork) {\n          if (process.env.NODE_ENV !== 'production') {\n            logger.debug(`Unable to respond with precached response. ` + `Falling back to network.`, error);\n          }\n\n          return fetch(request);\n        }\n\n        throw error;\n      }\n    };\n  }\n  /**\n   * Returns a function that looks up `url` in the precache (taking into\n   * account revision information), and returns the corresponding `Response`.\n   *\n   * If for an unexpected reason there is a cache miss when looking up `url`,\n   * this will fall back to retrieving the `Response` via `fetch()` when\n   * `fallbackToNetwork` is `true`.\n   *\n   * @param {string} url The precached URL which will be used to lookup the\n   * `Response`.\n   * @param {boolean} [fallbackToNetwork=true] Whether to attempt to get the\n   * response from the network if there's a precache miss.\n   * @return {module:workbox-routing~handlerCallback}\n   */\n\n\n  createHandlerBoundToURL(url, fallbackToNetwork = true) {\n    const cacheKey = this.getCacheKeyForURL(url);\n\n    if (!cacheKey) {\n      throw new WorkboxError('non-precached-url', {\n        url\n      });\n    }\n\n    const handler = this.createHandler(fallbackToNetwork);\n    const request = new Request(url);\n    return () => handler({\n      request\n    });\n  }\n\n}\n\nexport { PrecacheController };","map":{"version":3,"sources":["/Users/matthewcohen/Desktop/HTTBProject/HTTBFrontend/react-crud/node_modules/workbox-precaching/PrecacheController.js"],"names":["assert","cacheNames","cacheWrapper","fetchWrapper","logger","WorkboxError","copyResponse","createCacheKey","printCleanupDetails","printInstallDetails","PrecacheController","constructor","cacheName","_cacheName","getPrecacheName","_urlsToCacheKeys","Map","_urlsToCacheModes","_cacheKeysToIntegrities","addToCacheList","entries","process","env","NODE_ENV","isArray","moduleName","className","funcName","paramName","urlsToWarnAbout","entry","push","revision","undefined","url","cacheKey","cacheMode","has","get","firstEntry","secondEntry","integrity","set","length","warningMessage","join","console","warn","install","event","plugins","toBePrecached","alreadyPrecached","cache","self","caches","open","alreadyCachedRequests","keys","existingCacheKeys","Set","map","request","precacheRequests","_addURLToCache","Promise","all","updatedURLs","item","notUpdatedURLs","activate","currentlyCachedRequests","expectedCacheKeys","values","deletedURLs","delete","Request","credentials","response","fetch","cacheWillUpdatePlugin","plugin","isValidResponse","cacheWillUpdate","status","redirected","put","matchOptions","ignoreSearch","getURLsToCacheKeys","getCachedURLs","getCacheKeyForURL","urlObject","URL","location","href","matchPrecache","match","createHandler","fallbackToNetwork","error","debug","createHandlerBoundToURL","handler"],"mappings":"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","sourcesContent":["/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { cacheWrapper } from 'workbox-core/_private/cacheWrapper.js';\nimport { fetchWrapper } from 'workbox-core/_private/fetchWrapper.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { copyResponse } from 'workbox-core/copyResponse.js';\nimport { createCacheKey } from './utils/createCacheKey.js';\nimport { printCleanupDetails } from './utils/printCleanupDetails.js';\nimport { printInstallDetails } from './utils/printInstallDetails.js';\nimport './_version.js';\n/**\n * Performs efficient precaching of assets.\n *\n * @memberof module:workbox-precaching\n */\nclass PrecacheController {\n    /**\n     * Create a new PrecacheController.\n     *\n     * @param {string} [cacheName] An optional name for the cache, to override\n     * the default precache name.\n     */\n    constructor(cacheName) {\n        this._cacheName = cacheNames.getPrecacheName(cacheName);\n        this._urlsToCacheKeys = new Map();\n        this._urlsToCacheModes = new Map();\n        this._cacheKeysToIntegrities = new Map();\n    }\n    /**\n     * This method will add items to the precache list, removing duplicates\n     * and ensuring the information is valid.\n     *\n     * @param {\n     * Array<module:workbox-precaching.PrecacheController.PrecacheEntry|string>\n     * } entries Array of entries to precache.\n     */\n    addToCacheList(entries) {\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isArray(entries, {\n                moduleName: 'workbox-precaching',\n                className: 'PrecacheController',\n                funcName: 'addToCacheList',\n                paramName: 'entries',\n            });\n        }\n        const urlsToWarnAbout = [];\n        for (const entry of entries) {\n            // See https://github.com/GoogleChrome/workbox/issues/2259\n            if (typeof entry === 'string') {\n                urlsToWarnAbout.push(entry);\n            }\n            else if (entry && entry.revision === undefined) {\n                urlsToWarnAbout.push(entry.url);\n            }\n            const { cacheKey, url } = createCacheKey(entry);\n            const cacheMode = (typeof entry !== 'string' && entry.revision) ?\n                'reload' : 'default';\n            if (this._urlsToCacheKeys.has(url) &&\n                this._urlsToCacheKeys.get(url) !== cacheKey) {\n                throw new WorkboxError('add-to-cache-list-conflicting-entries', {\n                    firstEntry: this._urlsToCacheKeys.get(url),\n                    secondEntry: cacheKey,\n                });\n            }\n            if (typeof entry !== 'string' && entry.integrity) {\n                if (this._cacheKeysToIntegrities.has(cacheKey) &&\n                    this._cacheKeysToIntegrities.get(cacheKey) !== entry.integrity) {\n                    throw new WorkboxError('add-to-cache-list-conflicting-integrities', {\n                        url,\n                    });\n                }\n                this._cacheKeysToIntegrities.set(cacheKey, entry.integrity);\n            }\n            this._urlsToCacheKeys.set(url, cacheKey);\n            this._urlsToCacheModes.set(url, cacheMode);\n            if (urlsToWarnAbout.length > 0) {\n                const warningMessage = `Workbox is precaching URLs without revision ` +\n                    `info: ${urlsToWarnAbout.join(', ')}\\nThis is generally NOT safe. ` +\n                    `Learn more at https://bit.ly/wb-precache`;\n                if (process.env.NODE_ENV === 'production') {\n                    // Use console directly to display this warning without bloating\n                    // bundle sizes by pulling in all of the logger codebase in prod.\n                    console.warn(warningMessage);\n                }\n                else {\n                    logger.warn(warningMessage);\n                }\n            }\n        }\n    }\n    /**\n     * Precaches new and updated assets. Call this method from the service worker\n     * install event.\n     *\n     * @param {Object} options\n     * @param {Event} [options.event] The install event (if needed).\n     * @param {Array<Object>} [options.plugins] Plugins to be used for fetching\n     * and caching during install.\n     * @return {Promise<module:workbox-precaching.InstallResult>}\n     */\n    async install({ event, plugins } = {}) {\n        if (process.env.NODE_ENV !== 'production') {\n            if (plugins) {\n                assert.isArray(plugins, {\n                    moduleName: 'workbox-precaching',\n                    className: 'PrecacheController',\n                    funcName: 'install',\n                    paramName: 'plugins',\n                });\n            }\n        }\n        const toBePrecached = [];\n        const alreadyPrecached = [];\n        const cache = await self.caches.open(this._cacheName);\n        const alreadyCachedRequests = await cache.keys();\n        const existingCacheKeys = new Set(alreadyCachedRequests.map((request) => request.url));\n        for (const [url, cacheKey] of this._urlsToCacheKeys) {\n            if (existingCacheKeys.has(cacheKey)) {\n                alreadyPrecached.push(url);\n            }\n            else {\n                toBePrecached.push({ cacheKey, url });\n            }\n        }\n        const precacheRequests = toBePrecached.map(({ cacheKey, url }) => {\n            const integrity = this._cacheKeysToIntegrities.get(cacheKey);\n            const cacheMode = this._urlsToCacheModes.get(url);\n            return this._addURLToCache({\n                cacheKey,\n                cacheMode,\n                event,\n                integrity,\n                plugins,\n                url,\n            });\n        });\n        await Promise.all(precacheRequests);\n        const updatedURLs = toBePrecached.map((item) => item.url);\n        if (process.env.NODE_ENV !== 'production') {\n            printInstallDetails(updatedURLs, alreadyPrecached);\n        }\n        return {\n            updatedURLs,\n            notUpdatedURLs: alreadyPrecached,\n        };\n    }\n    /**\n     * Deletes assets that are no longer present in the current precache manifest.\n     * Call this method from the service worker activate event.\n     *\n     * @return {Promise<module:workbox-precaching.CleanupResult>}\n     */\n    async activate() {\n        const cache = await self.caches.open(this._cacheName);\n        const currentlyCachedRequests = await cache.keys();\n        const expectedCacheKeys = new Set(this._urlsToCacheKeys.values());\n        const deletedURLs = [];\n        for (const request of currentlyCachedRequests) {\n            if (!expectedCacheKeys.has(request.url)) {\n                await cache.delete(request);\n                deletedURLs.push(request.url);\n            }\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            printCleanupDetails(deletedURLs);\n        }\n        return { deletedURLs };\n    }\n    /**\n     * Requests the entry and saves it to the cache if the response is valid.\n     * By default, any response with a status code of less than 400 (including\n     * opaque responses) is considered valid.\n     *\n     * If you need to use custom criteria to determine what's valid and what\n     * isn't, then pass in an item in `options.plugins` that implements the\n     * `cacheWillUpdate()` lifecycle event.\n     *\n     * @private\n     * @param {Object} options\n     * @param {string} options.cacheKey The string to use a cache key.\n     * @param {string} options.url The URL to fetch and cache.\n     * @param {string} [options.cacheMode] The cache mode for the network request.\n     * @param {Event} [options.event] The install event (if passed).\n     * @param {Array<Object>} [options.plugins] An array of plugins to apply to\n     * fetch and caching.\n     * @param {string} [options.integrity] The value to use for the `integrity`\n     * field when making the request.\n     */\n    async _addURLToCache({ cacheKey, url, cacheMode, event, plugins, integrity }) {\n        const request = new Request(url, {\n            integrity,\n            cache: cacheMode,\n            credentials: 'same-origin',\n        });\n        let response = await fetchWrapper.fetch({\n            event,\n            plugins,\n            request,\n        });\n        // Allow developers to override the default logic about what is and isn't\n        // valid by passing in a plugin implementing cacheWillUpdate(), e.g.\n        // a `CacheableResponsePlugin` instance.\n        let cacheWillUpdatePlugin;\n        for (const plugin of (plugins || [])) {\n            if ('cacheWillUpdate' in plugin) {\n                cacheWillUpdatePlugin = plugin;\n            }\n        }\n        const isValidResponse = cacheWillUpdatePlugin ?\n            // Use a callback if provided. It returns a truthy value if valid.\n            // NOTE: invoke the method on the plugin instance so the `this` context\n            // is correct.\n            await cacheWillUpdatePlugin.cacheWillUpdate({ event, request, response }) :\n            // Otherwise, default to considering any response status under 400 valid.\n            // This includes, by default, considering opaque responses valid.\n            response.status < 400;\n        // Consider this a failure, leading to the `install` handler failing, if\n        // we get back an invalid response.\n        if (!isValidResponse) {\n            throw new WorkboxError('bad-precaching-response', {\n                url,\n                status: response.status,\n            });\n        }\n        // Redirected responses cannot be used to satisfy a navigation request, so\n        // any redirected response must be \"copied\" rather than cloned, so the new\n        // response doesn't contain the `redirected` flag. See:\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=669363&desc=2#c1\n        if (response.redirected) {\n            response = await copyResponse(response);\n        }\n        await cacheWrapper.put({\n            event,\n            plugins,\n            response,\n            // `request` already uses `url`. We may be able to reuse it.\n            request: cacheKey === url ? request : new Request(cacheKey),\n            cacheName: this._cacheName,\n            matchOptions: {\n                ignoreSearch: true,\n            },\n        });\n    }\n    /**\n     * Returns a mapping of a precached URL to the corresponding cache key, taking\n     * into account the revision information for the URL.\n     *\n     * @return {Map<string, string>} A URL to cache key mapping.\n     */\n    getURLsToCacheKeys() {\n        return this._urlsToCacheKeys;\n    }\n    /**\n     * Returns a list of all the URLs that have been precached by the current\n     * service worker.\n     *\n     * @return {Array<string>} The precached URLs.\n     */\n    getCachedURLs() {\n        return [...this._urlsToCacheKeys.keys()];\n    }\n    /**\n     * Returns the cache key used for storing a given URL. If that URL is\n     * unversioned, like `/index.html', then the cache key will be the original\n     * URL with a search parameter appended to it.\n     *\n     * @param {string} url A URL whose cache key you want to look up.\n     * @return {string} The versioned URL that corresponds to a cache key\n     * for the original URL, or undefined if that URL isn't precached.\n     */\n    getCacheKeyForURL(url) {\n        const urlObject = new URL(url, location.href);\n        return this._urlsToCacheKeys.get(urlObject.href);\n    }\n    /**\n     * This acts as a drop-in replacement for [`cache.match()`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/match)\n     * with the following differences:\n     *\n     * - It knows what the name of the precache is, and only checks in that cache.\n     * - It allows you to pass in an \"original\" URL without versioning parameters,\n     * and it will automatically look up the correct cache key for the currently\n     * active revision of that URL.\n     *\n     * E.g., `matchPrecache('index.html')` will find the correct precached\n     * response for the currently active service worker, even if the actual cache\n     * key is `'/index.html?__WB_REVISION__=1234abcd'`.\n     *\n     * @param {string|Request} request The key (without revisioning parameters)\n     * to look up in the precache.\n     * @return {Promise<Response|undefined>}\n     */\n    async matchPrecache(request) {\n        const url = request instanceof Request ? request.url : request;\n        const cacheKey = this.getCacheKeyForURL(url);\n        if (cacheKey) {\n            const cache = await self.caches.open(this._cacheName);\n            return cache.match(cacheKey);\n        }\n        return undefined;\n    }\n    /**\n     * Returns a function that can be used within a\n     * {@link module:workbox-routing.Route} that will find a response for the\n     * incoming request against the precache.\n     *\n     * If for an unexpected reason there is a cache miss for the request,\n     * this will fall back to retrieving the `Response` via `fetch()` when\n     * `fallbackToNetwork` is `true`.\n     *\n     * @param {boolean} [fallbackToNetwork=true] Whether to attempt to get the\n     * response from the network if there's a precache miss.\n     * @return {module:workbox-routing~handlerCallback}\n     */\n    createHandler(fallbackToNetwork = true) {\n        return async ({ request }) => {\n            try {\n                const response = await this.matchPrecache(request);\n                if (response) {\n                    return response;\n                }\n                // This shouldn't normally happen, but there are edge cases:\n                // https://github.com/GoogleChrome/workbox/issues/1441\n                throw new WorkboxError('missing-precache-entry', {\n                    cacheName: this._cacheName,\n                    url: request instanceof Request ? request.url : request,\n                });\n            }\n            catch (error) {\n                if (fallbackToNetwork) {\n                    if (process.env.NODE_ENV !== 'production') {\n                        logger.debug(`Unable to respond with precached response. ` +\n                            `Falling back to network.`, error);\n                    }\n                    return fetch(request);\n                }\n                throw error;\n            }\n        };\n    }\n    /**\n     * Returns a function that looks up `url` in the precache (taking into\n     * account revision information), and returns the corresponding `Response`.\n     *\n     * If for an unexpected reason there is a cache miss when looking up `url`,\n     * this will fall back to retrieving the `Response` via `fetch()` when\n     * `fallbackToNetwork` is `true`.\n     *\n     * @param {string} url The precached URL which will be used to lookup the\n     * `Response`.\n     * @param {boolean} [fallbackToNetwork=true] Whether to attempt to get the\n     * response from the network if there's a precache miss.\n     * @return {module:workbox-routing~handlerCallback}\n     */\n    createHandlerBoundToURL(url, fallbackToNetwork = true) {\n        const cacheKey = this.getCacheKeyForURL(url);\n        if (!cacheKey) {\n            throw new WorkboxError('non-precached-url', { url });\n        }\n        const handler = this.createHandler(fallbackToNetwork);\n        const request = new Request(url);\n        return () => handler({ request });\n    }\n}\nexport { PrecacheController };\n"]},"metadata":{},"sourceType":"module"}