{"ast":null,"code":"/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { WorkboxError } from './WorkboxError.js';\nimport { logger } from './logger.js';\nimport { assert } from './assert.js';\nimport { getFriendlyURL } from '../_private/getFriendlyURL.js';\nimport { pluginUtils } from '../utils/pluginUtils.js';\nimport '../_version.js';\n/**\n * Wrapper around the fetch API.\n *\n * Will call requestWillFetch on available plugins.\n *\n * @param {Object} options\n * @param {Request|string} options.request\n * @param {Object} [options.fetchOptions]\n * @param {ExtendableEvent} [options.event]\n * @param {Array<Object>} [options.plugins=[]]\n * @return {Promise<Response>}\n *\n * @private\n * @memberof module:workbox-core\n */\n\nconst wrappedFetch = async ({\n  request,\n  fetchOptions,\n  event,\n  plugins = []\n}) => {\n  if (typeof request === 'string') {\n    request = new Request(request);\n  } // We *should* be able to call `await event.preloadResponse` even if it's\n  // undefined, but for some reason, doing so leads to errors in our Node unit\n  // tests. To work around that, explicitly check preloadResponse's value first.\n\n\n  if (event instanceof FetchEvent && event.preloadResponse) {\n    const possiblePreloadResponse = await event.preloadResponse;\n\n    if (possiblePreloadResponse) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.log(`Using a preloaded navigation response for ` + `'${getFriendlyURL(request.url)}'`);\n      }\n\n      return possiblePreloadResponse;\n    }\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert.isInstance(request, Request, {\n      paramName: 'request',\n      expectedClass: Request,\n      moduleName: 'workbox-core',\n      className: 'fetchWrapper',\n      funcName: 'wrappedFetch'\n    });\n  }\n\n  const failedFetchPlugins = pluginUtils.filter(plugins, \"fetchDidFail\"\n  /* FETCH_DID_FAIL */\n  ); // If there is a fetchDidFail plugin, we need to save a clone of the\n  // original request before it's either modified by a requestWillFetch\n  // plugin or before the original request's body is consumed via fetch().\n\n  const originalRequest = failedFetchPlugins.length > 0 ? request.clone() : null;\n\n  try {\n    for (const plugin of plugins) {\n      if (\"requestWillFetch\"\n      /* REQUEST_WILL_FETCH */\n      in plugin) {\n        const pluginMethod = plugin[\"requestWillFetch\"\n        /* REQUEST_WILL_FETCH */\n        ];\n        const requestClone = request.clone();\n        request = await pluginMethod.call(plugin, {\n          request: requestClone,\n          event\n        });\n\n        if (process.env.NODE_ENV !== 'production') {\n          if (request) {\n            assert.isInstance(request, Request, {\n              moduleName: 'Plugin',\n              funcName: \"cachedResponseWillBeUsed\"\n              /* CACHED_RESPONSE_WILL_BE_USED */\n              ,\n              isReturnValueProblem: true\n            });\n          }\n        }\n      }\n    }\n  } catch (err) {\n    throw new WorkboxError('plugin-error-request-will-fetch', {\n      thrownError: err\n    });\n  } // The request can be altered by plugins with `requestWillFetch` making\n  // the original request (Most likely from a `fetch` event) to be different\n  // to the Request we make. Pass both to `fetchDidFail` to aid debugging.\n\n\n  const pluginFilteredRequest = request.clone();\n\n  try {\n    let fetchResponse; // See https://github.com/GoogleChrome/workbox/issues/1796\n\n    if (request.mode === 'navigate') {\n      fetchResponse = await fetch(request);\n    } else {\n      fetchResponse = await fetch(request, fetchOptions);\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      logger.debug(`Network request for ` + `'${getFriendlyURL(request.url)}' returned a response with ` + `status '${fetchResponse.status}'.`);\n    }\n\n    for (const plugin of plugins) {\n      if (\"fetchDidSucceed\"\n      /* FETCH_DID_SUCCEED */\n      in plugin) {\n        fetchResponse = await plugin[\"fetchDidSucceed\"\n        /* FETCH_DID_SUCCEED */\n        ].call(plugin, {\n          event,\n          request: pluginFilteredRequest,\n          response: fetchResponse\n        });\n\n        if (process.env.NODE_ENV !== 'production') {\n          if (fetchResponse) {\n            assert.isInstance(fetchResponse, Response, {\n              moduleName: 'Plugin',\n              funcName: \"fetchDidSucceed\"\n              /* FETCH_DID_SUCCEED */\n              ,\n              isReturnValueProblem: true\n            });\n          }\n        }\n      }\n    }\n\n    return fetchResponse;\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error(`Network request for ` + `'${getFriendlyURL(request.url)}' threw an error.`, error);\n    }\n\n    for (const plugin of failedFetchPlugins) {\n      await plugin[\"fetchDidFail\"\n      /* FETCH_DID_FAIL */\n      ].call(plugin, {\n        error,\n        event,\n        originalRequest: originalRequest.clone(),\n        request: pluginFilteredRequest.clone()\n      });\n    }\n\n    throw error;\n  }\n};\n\nconst fetchWrapper = {\n  fetch: wrappedFetch\n};\nexport { fetchWrapper };","map":{"version":3,"sources":["/Users/matthewcohen/Desktop/HTTBProject/HTTBFrontend/react-crud/node_modules/workbox-core/_private/fetchWrapper.js"],"names":["WorkboxError","logger","assert","getFriendlyURL","pluginUtils","wrappedFetch","request","fetchOptions","event","plugins","Request","FetchEvent","preloadResponse","possiblePreloadResponse","process","env","NODE_ENV","log","url","isInstance","paramName","expectedClass","moduleName","className","funcName","failedFetchPlugins","filter","originalRequest","length","clone","plugin","pluginMethod","requestClone","call","isReturnValueProblem","err","thrownError","pluginFilteredRequest","fetchResponse","mode","fetch","debug","status","response","Response","error","fetchWrapper"],"mappings":"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","sourcesContent":["/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { WorkboxError } from './WorkboxError.js';\nimport { logger } from './logger.js';\nimport { assert } from './assert.js';\nimport { getFriendlyURL } from '../_private/getFriendlyURL.js';\nimport { pluginUtils } from '../utils/pluginUtils.js';\nimport '../_version.js';\n/**\n * Wrapper around the fetch API.\n *\n * Will call requestWillFetch on available plugins.\n *\n * @param {Object} options\n * @param {Request|string} options.request\n * @param {Object} [options.fetchOptions]\n * @param {ExtendableEvent} [options.event]\n * @param {Array<Object>} [options.plugins=[]]\n * @return {Promise<Response>}\n *\n * @private\n * @memberof module:workbox-core\n */\nconst wrappedFetch = async ({ request, fetchOptions, event, plugins = [], }) => {\n    if (typeof request === 'string') {\n        request = new Request(request);\n    }\n    // We *should* be able to call `await event.preloadResponse` even if it's\n    // undefined, but for some reason, doing so leads to errors in our Node unit\n    // tests. To work around that, explicitly check preloadResponse's value first.\n    if (event instanceof FetchEvent && event.preloadResponse) {\n        const possiblePreloadResponse = await event.preloadResponse;\n        if (possiblePreloadResponse) {\n            if (process.env.NODE_ENV !== 'production') {\n                logger.log(`Using a preloaded navigation response for ` +\n                    `'${getFriendlyURL(request.url)}'`);\n            }\n            return possiblePreloadResponse;\n        }\n    }\n    if (process.env.NODE_ENV !== 'production') {\n        assert.isInstance(request, Request, {\n            paramName: 'request',\n            expectedClass: Request,\n            moduleName: 'workbox-core',\n            className: 'fetchWrapper',\n            funcName: 'wrappedFetch',\n        });\n    }\n    const failedFetchPlugins = pluginUtils.filter(plugins, \"fetchDidFail\" /* FETCH_DID_FAIL */);\n    // If there is a fetchDidFail plugin, we need to save a clone of the\n    // original request before it's either modified by a requestWillFetch\n    // plugin or before the original request's body is consumed via fetch().\n    const originalRequest = failedFetchPlugins.length > 0 ?\n        request.clone() : null;\n    try {\n        for (const plugin of plugins) {\n            if (\"requestWillFetch\" /* REQUEST_WILL_FETCH */ in plugin) {\n                const pluginMethod = plugin[\"requestWillFetch\" /* REQUEST_WILL_FETCH */];\n                const requestClone = request.clone();\n                request = await pluginMethod.call(plugin, {\n                    request: requestClone,\n                    event,\n                });\n                if (process.env.NODE_ENV !== 'production') {\n                    if (request) {\n                        assert.isInstance(request, Request, {\n                            moduleName: 'Plugin',\n                            funcName: \"cachedResponseWillBeUsed\" /* CACHED_RESPONSE_WILL_BE_USED */,\n                            isReturnValueProblem: true,\n                        });\n                    }\n                }\n            }\n        }\n    }\n    catch (err) {\n        throw new WorkboxError('plugin-error-request-will-fetch', {\n            thrownError: err,\n        });\n    }\n    // The request can be altered by plugins with `requestWillFetch` making\n    // the original request (Most likely from a `fetch` event) to be different\n    // to the Request we make. Pass both to `fetchDidFail` to aid debugging.\n    const pluginFilteredRequest = request.clone();\n    try {\n        let fetchResponse;\n        // See https://github.com/GoogleChrome/workbox/issues/1796\n        if (request.mode === 'navigate') {\n            fetchResponse = await fetch(request);\n        }\n        else {\n            fetchResponse = await fetch(request, fetchOptions);\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            logger.debug(`Network request for ` +\n                `'${getFriendlyURL(request.url)}' returned a response with ` +\n                `status '${fetchResponse.status}'.`);\n        }\n        for (const plugin of plugins) {\n            if (\"fetchDidSucceed\" /* FETCH_DID_SUCCEED */ in plugin) {\n                fetchResponse = await plugin[\"fetchDidSucceed\" /* FETCH_DID_SUCCEED */]\n                    .call(plugin, {\n                    event,\n                    request: pluginFilteredRequest,\n                    response: fetchResponse,\n                });\n                if (process.env.NODE_ENV !== 'production') {\n                    if (fetchResponse) {\n                        assert.isInstance(fetchResponse, Response, {\n                            moduleName: 'Plugin',\n                            funcName: \"fetchDidSucceed\" /* FETCH_DID_SUCCEED */,\n                            isReturnValueProblem: true,\n                        });\n                    }\n                }\n            }\n        }\n        return fetchResponse;\n    }\n    catch (error) {\n        if (process.env.NODE_ENV !== 'production') {\n            logger.error(`Network request for ` +\n                `'${getFriendlyURL(request.url)}' threw an error.`, error);\n        }\n        for (const plugin of failedFetchPlugins) {\n            await plugin[\"fetchDidFail\" /* FETCH_DID_FAIL */].call(plugin, {\n                error,\n                event,\n                originalRequest: originalRequest.clone(),\n                request: pluginFilteredRequest.clone(),\n            });\n        }\n        throw error;\n    }\n};\nconst fetchWrapper = {\n    fetch: wrappedFetch,\n};\nexport { fetchWrapper };\n"]},"metadata":{},"sourceType":"module"}