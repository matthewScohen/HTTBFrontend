{"ast":null,"code":"/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { dontWaitFor } from 'workbox-core/_private/dontWaitFor.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { CacheTimestampsModel } from './models/CacheTimestampsModel.js';\nimport './_version.js';\n/**\n * The `CacheExpiration` class allows you define an expiration and / or\n * limit on the number of responses stored in a\n * [`Cache`](https://developer.mozilla.org/en-US/docs/Web/API/Cache).\n *\n * @memberof module:workbox-expiration\n */\n\nclass CacheExpiration {\n  /**\n   * To construct a new CacheExpiration instance you must provide at least\n   * one of the `config` properties.\n   *\n   * @param {string} cacheName Name of the cache to apply restrictions to.\n   * @param {Object} config\n   * @param {number} [config.maxEntries] The maximum number of entries to cache.\n   * Entries used the least will be removed as the maximum is reached.\n   * @param {number} [config.maxAgeSeconds] The maximum age of an entry before\n   * it's treated as stale and removed.\n   */\n  constructor(cacheName, config = {}) {\n    this._isRunning = false;\n    this._rerunRequested = false;\n\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(cacheName, 'string', {\n        moduleName: 'workbox-expiration',\n        className: 'CacheExpiration',\n        funcName: 'constructor',\n        paramName: 'cacheName'\n      });\n\n      if (!(config.maxEntries || config.maxAgeSeconds)) {\n        throw new WorkboxError('max-entries-or-age-required', {\n          moduleName: 'workbox-expiration',\n          className: 'CacheExpiration',\n          funcName: 'constructor'\n        });\n      }\n\n      if (config.maxEntries) {\n        assert.isType(config.maxEntries, 'number', {\n          moduleName: 'workbox-expiration',\n          className: 'CacheExpiration',\n          funcName: 'constructor',\n          paramName: 'config.maxEntries'\n        }); // TODO: Assert is positive\n      }\n\n      if (config.maxAgeSeconds) {\n        assert.isType(config.maxAgeSeconds, 'number', {\n          moduleName: 'workbox-expiration',\n          className: 'CacheExpiration',\n          funcName: 'constructor',\n          paramName: 'config.maxAgeSeconds'\n        }); // TODO: Assert is positive\n      }\n    }\n\n    this._maxEntries = config.maxEntries;\n    this._maxAgeSeconds = config.maxAgeSeconds;\n    this._cacheName = cacheName;\n    this._timestampModel = new CacheTimestampsModel(cacheName);\n  }\n  /**\n   * Expires entries for the given cache and given criteria.\n   */\n\n\n  async expireEntries() {\n    if (this._isRunning) {\n      this._rerunRequested = true;\n      return;\n    }\n\n    this._isRunning = true;\n    const minTimestamp = this._maxAgeSeconds ? Date.now() - this._maxAgeSeconds * 1000 : 0;\n    const urlsExpired = await this._timestampModel.expireEntries(minTimestamp, this._maxEntries); // Delete URLs from the cache\n\n    const cache = await self.caches.open(this._cacheName);\n\n    for (const url of urlsExpired) {\n      await cache.delete(url);\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (urlsExpired.length > 0) {\n        logger.groupCollapsed(`Expired ${urlsExpired.length} ` + `${urlsExpired.length === 1 ? 'entry' : 'entries'} and removed ` + `${urlsExpired.length === 1 ? 'it' : 'them'} from the ` + `'${this._cacheName}' cache.`);\n        logger.log(`Expired the following ${urlsExpired.length === 1 ? 'URL' : 'URLs'}:`);\n        urlsExpired.forEach(url => logger.log(`    ${url}`));\n        logger.groupEnd();\n      } else {\n        logger.debug(`Cache expiration ran and found no entries to remove.`);\n      }\n    }\n\n    this._isRunning = false;\n\n    if (this._rerunRequested) {\n      this._rerunRequested = false;\n      dontWaitFor(this.expireEntries());\n    }\n  }\n  /**\n   * Update the timestamp for the given URL. This ensures the when\n   * removing entries based on maximum entries, most recently used\n   * is accurate or when expiring, the timestamp is up-to-date.\n   *\n   * @param {string} url\n   */\n\n\n  async updateTimestamp(url) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(url, 'string', {\n        moduleName: 'workbox-expiration',\n        className: 'CacheExpiration',\n        funcName: 'updateTimestamp',\n        paramName: 'url'\n      });\n    }\n\n    await this._timestampModel.setTimestamp(url, Date.now());\n  }\n  /**\n   * Can be used to check if a URL has expired or not before it's used.\n   *\n   * This requires a look up from IndexedDB, so can be slow.\n   *\n   * Note: This method will not remove the cached entry, call\n   * `expireEntries()` to remove indexedDB and Cache entries.\n   *\n   * @param {string} url\n   * @return {boolean}\n   */\n\n\n  async isURLExpired(url) {\n    if (!this._maxAgeSeconds) {\n      if (process.env.NODE_ENV !== 'production') {\n        throw new WorkboxError(`expired-test-without-max-age`, {\n          methodName: 'isURLExpired',\n          paramName: 'maxAgeSeconds'\n        });\n      }\n\n      return false;\n    } else {\n      const timestamp = await this._timestampModel.getTimestamp(url);\n      const expireOlderThan = Date.now() - this._maxAgeSeconds * 1000;\n      return timestamp < expireOlderThan;\n    }\n  }\n  /**\n   * Removes the IndexedDB object store used to keep track of cache expiration\n   * metadata.\n   */\n\n\n  async delete() {\n    // Make sure we don't attempt another rerun if we're called in the middle of\n    // a cache expiration.\n    this._rerunRequested = false;\n    await this._timestampModel.expireEntries(Infinity); // Expires all.\n  }\n\n}\n\nexport { CacheExpiration };","map":{"version":3,"sources":["/Users/matthewcohen/Desktop/HTTBProject/HTTBFrontend/react-crud/node_modules/workbox-expiration/CacheExpiration.js"],"names":["assert","dontWaitFor","logger","WorkboxError","CacheTimestampsModel","CacheExpiration","constructor","cacheName","config","_isRunning","_rerunRequested","process","env","NODE_ENV","isType","moduleName","className","funcName","paramName","maxEntries","maxAgeSeconds","_maxEntries","_maxAgeSeconds","_cacheName","_timestampModel","expireEntries","minTimestamp","Date","now","urlsExpired","cache","self","caches","open","url","delete","length","groupCollapsed","log","forEach","groupEnd","debug","updateTimestamp","setTimestamp","isURLExpired","methodName","timestamp","getTimestamp","expireOlderThan","Infinity"],"mappings":"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","sourcesContent":["/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { dontWaitFor } from 'workbox-core/_private/dontWaitFor.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { CacheTimestampsModel } from './models/CacheTimestampsModel.js';\nimport './_version.js';\n/**\n * The `CacheExpiration` class allows you define an expiration and / or\n * limit on the number of responses stored in a\n * [`Cache`](https://developer.mozilla.org/en-US/docs/Web/API/Cache).\n *\n * @memberof module:workbox-expiration\n */\nclass CacheExpiration {\n    /**\n     * To construct a new CacheExpiration instance you must provide at least\n     * one of the `config` properties.\n     *\n     * @param {string} cacheName Name of the cache to apply restrictions to.\n     * @param {Object} config\n     * @param {number} [config.maxEntries] The maximum number of entries to cache.\n     * Entries used the least will be removed as the maximum is reached.\n     * @param {number} [config.maxAgeSeconds] The maximum age of an entry before\n     * it's treated as stale and removed.\n     */\n    constructor(cacheName, config = {}) {\n        this._isRunning = false;\n        this._rerunRequested = false;\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isType(cacheName, 'string', {\n                moduleName: 'workbox-expiration',\n                className: 'CacheExpiration',\n                funcName: 'constructor',\n                paramName: 'cacheName',\n            });\n            if (!(config.maxEntries || config.maxAgeSeconds)) {\n                throw new WorkboxError('max-entries-or-age-required', {\n                    moduleName: 'workbox-expiration',\n                    className: 'CacheExpiration',\n                    funcName: 'constructor',\n                });\n            }\n            if (config.maxEntries) {\n                assert.isType(config.maxEntries, 'number', {\n                    moduleName: 'workbox-expiration',\n                    className: 'CacheExpiration',\n                    funcName: 'constructor',\n                    paramName: 'config.maxEntries',\n                });\n                // TODO: Assert is positive\n            }\n            if (config.maxAgeSeconds) {\n                assert.isType(config.maxAgeSeconds, 'number', {\n                    moduleName: 'workbox-expiration',\n                    className: 'CacheExpiration',\n                    funcName: 'constructor',\n                    paramName: 'config.maxAgeSeconds',\n                });\n                // TODO: Assert is positive\n            }\n        }\n        this._maxEntries = config.maxEntries;\n        this._maxAgeSeconds = config.maxAgeSeconds;\n        this._cacheName = cacheName;\n        this._timestampModel = new CacheTimestampsModel(cacheName);\n    }\n    /**\n     * Expires entries for the given cache and given criteria.\n     */\n    async expireEntries() {\n        if (this._isRunning) {\n            this._rerunRequested = true;\n            return;\n        }\n        this._isRunning = true;\n        const minTimestamp = this._maxAgeSeconds ?\n            Date.now() - (this._maxAgeSeconds * 1000) : 0;\n        const urlsExpired = await this._timestampModel.expireEntries(minTimestamp, this._maxEntries);\n        // Delete URLs from the cache\n        const cache = await self.caches.open(this._cacheName);\n        for (const url of urlsExpired) {\n            await cache.delete(url);\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            if (urlsExpired.length > 0) {\n                logger.groupCollapsed(`Expired ${urlsExpired.length} ` +\n                    `${urlsExpired.length === 1 ? 'entry' : 'entries'} and removed ` +\n                    `${urlsExpired.length === 1 ? 'it' : 'them'} from the ` +\n                    `'${this._cacheName}' cache.`);\n                logger.log(`Expired the following ${urlsExpired.length === 1 ?\n                    'URL' : 'URLs'}:`);\n                urlsExpired.forEach((url) => logger.log(`    ${url}`));\n                logger.groupEnd();\n            }\n            else {\n                logger.debug(`Cache expiration ran and found no entries to remove.`);\n            }\n        }\n        this._isRunning = false;\n        if (this._rerunRequested) {\n            this._rerunRequested = false;\n            dontWaitFor(this.expireEntries());\n        }\n    }\n    /**\n     * Update the timestamp for the given URL. This ensures the when\n     * removing entries based on maximum entries, most recently used\n     * is accurate or when expiring, the timestamp is up-to-date.\n     *\n     * @param {string} url\n     */\n    async updateTimestamp(url) {\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isType(url, 'string', {\n                moduleName: 'workbox-expiration',\n                className: 'CacheExpiration',\n                funcName: 'updateTimestamp',\n                paramName: 'url',\n            });\n        }\n        await this._timestampModel.setTimestamp(url, Date.now());\n    }\n    /**\n     * Can be used to check if a URL has expired or not before it's used.\n     *\n     * This requires a look up from IndexedDB, so can be slow.\n     *\n     * Note: This method will not remove the cached entry, call\n     * `expireEntries()` to remove indexedDB and Cache entries.\n     *\n     * @param {string} url\n     * @return {boolean}\n     */\n    async isURLExpired(url) {\n        if (!this._maxAgeSeconds) {\n            if (process.env.NODE_ENV !== 'production') {\n                throw new WorkboxError(`expired-test-without-max-age`, {\n                    methodName: 'isURLExpired',\n                    paramName: 'maxAgeSeconds',\n                });\n            }\n            return false;\n        }\n        else {\n            const timestamp = await this._timestampModel.getTimestamp(url);\n            const expireOlderThan = Date.now() - (this._maxAgeSeconds * 1000);\n            return (timestamp < expireOlderThan);\n        }\n    }\n    /**\n     * Removes the IndexedDB object store used to keep track of cache expiration\n     * metadata.\n     */\n    async delete() {\n        // Make sure we don't attempt another rerun if we're called in the middle of\n        // a cache expiration.\n        this._rerunRequested = false;\n        await this._timestampModel.expireEntries(Infinity); // Expires all.\n    }\n}\nexport { CacheExpiration };\n"]},"metadata":{},"sourceType":"module"}