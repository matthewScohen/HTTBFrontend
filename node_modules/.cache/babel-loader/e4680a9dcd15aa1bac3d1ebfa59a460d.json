{"ast":null,"code":"/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from './assert.js';\nimport { executeQuotaErrorCallbacks } from './executeQuotaErrorCallbacks.js';\nimport { getFriendlyURL } from './getFriendlyURL.js';\nimport { logger } from './logger.js';\nimport { pluginUtils } from '../utils/pluginUtils.js';\nimport { WorkboxError } from './WorkboxError.js';\nimport '../_version.js';\n/**\n * Checks the list of plugins for the cacheKeyWillBeUsed callback, and\n * executes any of those callbacks found in sequence. The final `Request` object\n * returned by the last plugin is treated as the cache key for cache reads\n * and/or writes.\n *\n * @param {Object} options\n * @param {Request} options.request\n * @param {string} options.mode\n * @param {Array<Object>} [options.plugins=[]]\n * @return {Promise<Request>}\n *\n * @private\n * @memberof module:workbox-core\n */\n\nconst _getEffectiveRequest = async ({\n  request,\n  mode,\n  plugins = []\n}) => {\n  const cacheKeyWillBeUsedPlugins = pluginUtils.filter(plugins, \"cacheKeyWillBeUsed\"\n  /* CACHE_KEY_WILL_BE_USED */\n  );\n  let effectiveRequest = request;\n\n  for (const plugin of cacheKeyWillBeUsedPlugins) {\n    effectiveRequest = await plugin[\"cacheKeyWillBeUsed\"\n    /* CACHE_KEY_WILL_BE_USED */\n    ].call(plugin, {\n      mode,\n      request: effectiveRequest\n    });\n\n    if (typeof effectiveRequest === 'string') {\n      effectiveRequest = new Request(effectiveRequest);\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isInstance(effectiveRequest, Request, {\n        moduleName: 'Plugin',\n        funcName: \"cacheKeyWillBeUsed\"\n        /* CACHE_KEY_WILL_BE_USED */\n        ,\n        isReturnValueProblem: true\n      });\n    }\n  }\n\n  return effectiveRequest;\n};\n/**\n * This method will call cacheWillUpdate on the available plugins (or use\n * status === 200) to determine if the Response is safe and valid to cache.\n *\n * @param {Object} options\n * @param {Request} options.request\n * @param {Response} options.response\n * @param {Event} [options.event]\n * @param {Array<Object>} [options.plugins=[]]\n * @return {Promise<Response>}\n *\n * @private\n * @memberof module:workbox-core\n */\n\n\nconst _isResponseSafeToCache = async ({\n  request,\n  response,\n  event,\n  plugins = []\n}) => {\n  let responseToCache = response;\n  let pluginsUsed = false;\n\n  for (const plugin of plugins) {\n    if (\"cacheWillUpdate\"\n    /* CACHE_WILL_UPDATE */\n    in plugin) {\n      pluginsUsed = true;\n      const pluginMethod = plugin[\"cacheWillUpdate\"\n      /* CACHE_WILL_UPDATE */\n      ];\n      responseToCache = await pluginMethod.call(plugin, {\n        request,\n        response: responseToCache,\n        event\n      });\n\n      if (process.env.NODE_ENV !== 'production') {\n        if (responseToCache) {\n          assert.isInstance(responseToCache, Response, {\n            moduleName: 'Plugin',\n            funcName: \"cacheWillUpdate\"\n            /* CACHE_WILL_UPDATE */\n            ,\n            isReturnValueProblem: true\n          });\n        }\n      }\n\n      if (!responseToCache) {\n        break;\n      }\n    }\n  }\n\n  if (!pluginsUsed) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (responseToCache) {\n        if (responseToCache.status !== 200) {\n          if (responseToCache.status === 0) {\n            logger.warn(`The response for '${request.url}' is an opaque ` + `response. The caching strategy that you're using will not ` + `cache opaque responses by default.`);\n          } else {\n            logger.debug(`The response for '${request.url}' returned ` + `a status code of '${response.status}' and won't be cached as a ` + `result.`);\n          }\n        }\n      }\n    }\n\n    responseToCache = responseToCache && responseToCache.status === 200 ? responseToCache : undefined;\n  }\n\n  return responseToCache ? responseToCache : null;\n};\n/**\n * This is a wrapper around cache.match().\n *\n * @param {Object} options\n * @param {string} options.cacheName Name of the cache to match against.\n * @param {Request} options.request The Request that will be used to look up\n *     cache entries.\n * @param {Event} [options.event] The event that prompted the action.\n * @param {Object} [options.matchOptions] Options passed to cache.match().\n * @param {Array<Object>} [options.plugins=[]] Array of plugins.\n * @return {Response} A cached response if available.\n *\n * @private\n * @memberof module:workbox-core\n */\n\n\nconst matchWrapper = async ({\n  cacheName,\n  request,\n  event,\n  matchOptions,\n  plugins = []\n}) => {\n  const cache = await self.caches.open(cacheName);\n  const effectiveRequest = await _getEffectiveRequest({\n    plugins,\n    request,\n    mode: 'read'\n  });\n  let cachedResponse = await cache.match(effectiveRequest, matchOptions);\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (cachedResponse) {\n      logger.debug(`Found a cached response in '${cacheName}'.`);\n    } else {\n      logger.debug(`No cached response found in '${cacheName}'.`);\n    }\n  }\n\n  for (const plugin of plugins) {\n    if (\"cachedResponseWillBeUsed\"\n    /* CACHED_RESPONSE_WILL_BE_USED */\n    in plugin) {\n      const pluginMethod = plugin[\"cachedResponseWillBeUsed\"\n      /* CACHED_RESPONSE_WILL_BE_USED */\n      ];\n      cachedResponse = await pluginMethod.call(plugin, {\n        cacheName,\n        event,\n        matchOptions,\n        cachedResponse,\n        request: effectiveRequest\n      });\n\n      if (process.env.NODE_ENV !== 'production') {\n        if (cachedResponse) {\n          assert.isInstance(cachedResponse, Response, {\n            moduleName: 'Plugin',\n            funcName: \"cachedResponseWillBeUsed\"\n            /* CACHED_RESPONSE_WILL_BE_USED */\n            ,\n            isReturnValueProblem: true\n          });\n        }\n      }\n    }\n  }\n\n  return cachedResponse;\n};\n/**\n * Wrapper around cache.put().\n *\n * Will call `cacheDidUpdate` on plugins if the cache was updated, using\n * `matchOptions` when determining what the old entry is.\n *\n * @param {Object} options\n * @param {string} options.cacheName\n * @param {Request} options.request\n * @param {Response} options.response\n * @param {Event} [options.event]\n * @param {Array<Object>} [options.plugins=[]]\n * @param {Object} [options.matchOptions]\n *\n * @private\n * @memberof module:workbox-core\n */\n\n\nconst putWrapper = async ({\n  cacheName,\n  request,\n  response,\n  event,\n  plugins = [],\n  matchOptions\n}) => {\n  if (process.env.NODE_ENV !== 'production') {\n    if (request.method && request.method !== 'GET') {\n      throw new WorkboxError('attempt-to-cache-non-get-request', {\n        url: getFriendlyURL(request.url),\n        method: request.method\n      });\n    }\n  }\n\n  const effectiveRequest = await _getEffectiveRequest({\n    plugins,\n    request,\n    mode: 'write'\n  });\n\n  if (!response) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error(`Cannot cache non-existent response for ` + `'${getFriendlyURL(effectiveRequest.url)}'.`);\n    }\n\n    throw new WorkboxError('cache-put-with-no-response', {\n      url: getFriendlyURL(effectiveRequest.url)\n    });\n  }\n\n  const responseToCache = await _isResponseSafeToCache({\n    event,\n    plugins,\n    response,\n    request: effectiveRequest\n  });\n\n  if (!responseToCache) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.debug(`Response '${getFriendlyURL(effectiveRequest.url)}' will ` + `not be cached.`, responseToCache);\n    }\n\n    return;\n  }\n\n  const cache = await self.caches.open(cacheName);\n  const updatePlugins = pluginUtils.filter(plugins, \"cacheDidUpdate\"\n  /* CACHE_DID_UPDATE */\n  );\n  const oldResponse = updatePlugins.length > 0 ? await matchWrapper({\n    cacheName,\n    matchOptions,\n    request: effectiveRequest\n  }) : null;\n\n  if (process.env.NODE_ENV !== 'production') {\n    logger.debug(`Updating the '${cacheName}' cache with a new Response for ` + `${getFriendlyURL(effectiveRequest.url)}.`);\n  }\n\n  try {\n    await cache.put(effectiveRequest, responseToCache);\n  } catch (error) {\n    // See https://developer.mozilla.org/en-US/docs/Web/API/DOMException#exception-QuotaExceededError\n    if (error.name === 'QuotaExceededError') {\n      await executeQuotaErrorCallbacks();\n    }\n\n    throw error;\n  }\n\n  for (const plugin of updatePlugins) {\n    await plugin[\"cacheDidUpdate\"\n    /* CACHE_DID_UPDATE */\n    ].call(plugin, {\n      cacheName,\n      event,\n      oldResponse,\n      newResponse: responseToCache,\n      request: effectiveRequest\n    });\n  }\n};\n\nexport const cacheWrapper = {\n  put: putWrapper,\n  match: matchWrapper\n};","map":{"version":3,"sources":["/Users/matthewcohen/Desktop/HTTBProject/HTTBFrontend/react-crud/node_modules/workbox-core/_private/cacheWrapper.js"],"names":["assert","executeQuotaErrorCallbacks","getFriendlyURL","logger","pluginUtils","WorkboxError","_getEffectiveRequest","request","mode","plugins","cacheKeyWillBeUsedPlugins","filter","effectiveRequest","plugin","call","Request","process","env","NODE_ENV","isInstance","moduleName","funcName","isReturnValueProblem","_isResponseSafeToCache","response","event","responseToCache","pluginsUsed","pluginMethod","Response","status","warn","url","debug","undefined","matchWrapper","cacheName","matchOptions","cache","self","caches","open","cachedResponse","match","putWrapper","method","error","updatePlugins","oldResponse","length","put","name","newResponse","cacheWrapper"],"mappings":"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","sourcesContent":["/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from './assert.js';\nimport { executeQuotaErrorCallbacks } from './executeQuotaErrorCallbacks.js';\nimport { getFriendlyURL } from './getFriendlyURL.js';\nimport { logger } from './logger.js';\nimport { pluginUtils } from '../utils/pluginUtils.js';\nimport { WorkboxError } from './WorkboxError.js';\nimport '../_version.js';\n/**\n * Checks the list of plugins for the cacheKeyWillBeUsed callback, and\n * executes any of those callbacks found in sequence. The final `Request` object\n * returned by the last plugin is treated as the cache key for cache reads\n * and/or writes.\n *\n * @param {Object} options\n * @param {Request} options.request\n * @param {string} options.mode\n * @param {Array<Object>} [options.plugins=[]]\n * @return {Promise<Request>}\n *\n * @private\n * @memberof module:workbox-core\n */\nconst _getEffectiveRequest = async ({ request, mode, plugins = [], }) => {\n    const cacheKeyWillBeUsedPlugins = pluginUtils.filter(plugins, \"cacheKeyWillBeUsed\" /* CACHE_KEY_WILL_BE_USED */);\n    let effectiveRequest = request;\n    for (const plugin of cacheKeyWillBeUsedPlugins) {\n        effectiveRequest = await plugin[\"cacheKeyWillBeUsed\" /* CACHE_KEY_WILL_BE_USED */].call(plugin, { mode, request: effectiveRequest });\n        if (typeof effectiveRequest === 'string') {\n            effectiveRequest = new Request(effectiveRequest);\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(effectiveRequest, Request, {\n                moduleName: 'Plugin',\n                funcName: \"cacheKeyWillBeUsed\" /* CACHE_KEY_WILL_BE_USED */,\n                isReturnValueProblem: true,\n            });\n        }\n    }\n    return effectiveRequest;\n};\n/**\n * This method will call cacheWillUpdate on the available plugins (or use\n * status === 200) to determine if the Response is safe and valid to cache.\n *\n * @param {Object} options\n * @param {Request} options.request\n * @param {Response} options.response\n * @param {Event} [options.event]\n * @param {Array<Object>} [options.plugins=[]]\n * @return {Promise<Response>}\n *\n * @private\n * @memberof module:workbox-core\n */\nconst _isResponseSafeToCache = async ({ request, response, event, plugins = [], }) => {\n    let responseToCache = response;\n    let pluginsUsed = false;\n    for (const plugin of plugins) {\n        if (\"cacheWillUpdate\" /* CACHE_WILL_UPDATE */ in plugin) {\n            pluginsUsed = true;\n            const pluginMethod = plugin[\"cacheWillUpdate\" /* CACHE_WILL_UPDATE */];\n            responseToCache = await pluginMethod.call(plugin, {\n                request,\n                response: responseToCache,\n                event,\n            });\n            if (process.env.NODE_ENV !== 'production') {\n                if (responseToCache) {\n                    assert.isInstance(responseToCache, Response, {\n                        moduleName: 'Plugin',\n                        funcName: \"cacheWillUpdate\" /* CACHE_WILL_UPDATE */,\n                        isReturnValueProblem: true,\n                    });\n                }\n            }\n            if (!responseToCache) {\n                break;\n            }\n        }\n    }\n    if (!pluginsUsed) {\n        if (process.env.NODE_ENV !== 'production') {\n            if (responseToCache) {\n                if (responseToCache.status !== 200) {\n                    if (responseToCache.status === 0) {\n                        logger.warn(`The response for '${request.url}' is an opaque ` +\n                            `response. The caching strategy that you're using will not ` +\n                            `cache opaque responses by default.`);\n                    }\n                    else {\n                        logger.debug(`The response for '${request.url}' returned ` +\n                            `a status code of '${response.status}' and won't be cached as a ` +\n                            `result.`);\n                    }\n                }\n            }\n        }\n        responseToCache = responseToCache && responseToCache.status === 200 ?\n            responseToCache : undefined;\n    }\n    return responseToCache ? responseToCache : null;\n};\n/**\n * This is a wrapper around cache.match().\n *\n * @param {Object} options\n * @param {string} options.cacheName Name of the cache to match against.\n * @param {Request} options.request The Request that will be used to look up\n *     cache entries.\n * @param {Event} [options.event] The event that prompted the action.\n * @param {Object} [options.matchOptions] Options passed to cache.match().\n * @param {Array<Object>} [options.plugins=[]] Array of plugins.\n * @return {Response} A cached response if available.\n *\n * @private\n * @memberof module:workbox-core\n */\nconst matchWrapper = async ({ cacheName, request, event, matchOptions, plugins = [], }) => {\n    const cache = await self.caches.open(cacheName);\n    const effectiveRequest = await _getEffectiveRequest({\n        plugins, request, mode: 'read'\n    });\n    let cachedResponse = await cache.match(effectiveRequest, matchOptions);\n    if (process.env.NODE_ENV !== 'production') {\n        if (cachedResponse) {\n            logger.debug(`Found a cached response in '${cacheName}'.`);\n        }\n        else {\n            logger.debug(`No cached response found in '${cacheName}'.`);\n        }\n    }\n    for (const plugin of plugins) {\n        if (\"cachedResponseWillBeUsed\" /* CACHED_RESPONSE_WILL_BE_USED */ in plugin) {\n            const pluginMethod = plugin[\"cachedResponseWillBeUsed\" /* CACHED_RESPONSE_WILL_BE_USED */];\n            cachedResponse = await pluginMethod.call(plugin, {\n                cacheName,\n                event,\n                matchOptions,\n                cachedResponse,\n                request: effectiveRequest,\n            });\n            if (process.env.NODE_ENV !== 'production') {\n                if (cachedResponse) {\n                    assert.isInstance(cachedResponse, Response, {\n                        moduleName: 'Plugin',\n                        funcName: \"cachedResponseWillBeUsed\" /* CACHED_RESPONSE_WILL_BE_USED */,\n                        isReturnValueProblem: true,\n                    });\n                }\n            }\n        }\n    }\n    return cachedResponse;\n};\n/**\n * Wrapper around cache.put().\n *\n * Will call `cacheDidUpdate` on plugins if the cache was updated, using\n * `matchOptions` when determining what the old entry is.\n *\n * @param {Object} options\n * @param {string} options.cacheName\n * @param {Request} options.request\n * @param {Response} options.response\n * @param {Event} [options.event]\n * @param {Array<Object>} [options.plugins=[]]\n * @param {Object} [options.matchOptions]\n *\n * @private\n * @memberof module:workbox-core\n */\nconst putWrapper = async ({ cacheName, request, response, event, plugins = [], matchOptions, }) => {\n    if (process.env.NODE_ENV !== 'production') {\n        if (request.method && request.method !== 'GET') {\n            throw new WorkboxError('attempt-to-cache-non-get-request', {\n                url: getFriendlyURL(request.url),\n                method: request.method,\n            });\n        }\n    }\n    const effectiveRequest = await _getEffectiveRequest({\n        plugins, request, mode: 'write'\n    });\n    if (!response) {\n        if (process.env.NODE_ENV !== 'production') {\n            logger.error(`Cannot cache non-existent response for ` +\n                `'${getFriendlyURL(effectiveRequest.url)}'.`);\n        }\n        throw new WorkboxError('cache-put-with-no-response', {\n            url: getFriendlyURL(effectiveRequest.url),\n        });\n    }\n    const responseToCache = await _isResponseSafeToCache({\n        event,\n        plugins,\n        response,\n        request: effectiveRequest,\n    });\n    if (!responseToCache) {\n        if (process.env.NODE_ENV !== 'production') {\n            logger.debug(`Response '${getFriendlyURL(effectiveRequest.url)}' will ` +\n                `not be cached.`, responseToCache);\n        }\n        return;\n    }\n    const cache = await self.caches.open(cacheName);\n    const updatePlugins = pluginUtils.filter(plugins, \"cacheDidUpdate\" /* CACHE_DID_UPDATE */);\n    const oldResponse = updatePlugins.length > 0 ?\n        await matchWrapper({ cacheName, matchOptions, request: effectiveRequest }) :\n        null;\n    if (process.env.NODE_ENV !== 'production') {\n        logger.debug(`Updating the '${cacheName}' cache with a new Response for ` +\n            `${getFriendlyURL(effectiveRequest.url)}.`);\n    }\n    try {\n        await cache.put(effectiveRequest, responseToCache);\n    }\n    catch (error) {\n        // See https://developer.mozilla.org/en-US/docs/Web/API/DOMException#exception-QuotaExceededError\n        if (error.name === 'QuotaExceededError') {\n            await executeQuotaErrorCallbacks();\n        }\n        throw error;\n    }\n    for (const plugin of updatePlugins) {\n        await plugin[\"cacheDidUpdate\" /* CACHE_DID_UPDATE */].call(plugin, {\n            cacheName,\n            event,\n            oldResponse,\n            newResponse: responseToCache,\n            request: effectiveRequest,\n        });\n    }\n};\nexport const cacheWrapper = {\n    put: putWrapper,\n    match: matchWrapper,\n};\n"]},"metadata":{},"sourceType":"module"}